// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL") // Only needed when using a cloud provider that doesn't support the creation of new databases, like Heroku. Learn more: https://pris.ly/d/migrate-shadow
}

generator client {
  provider = "prisma-client-js"
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                    String              @id @default(cuid())
  name                  String?
  email                 String?             @unique
  emailVerified         DateTime?
  image                 String?
  password              String?
  passwordResetToken    String?             @unique
  passwordResetTokenExp DateTime?
  role                  String              @default("creator") // creator, platform_owner
  subscriptionStatus    SubscriptionStatus  @default(FREE)
  accounts              Account[]
  sessions              Session[]
  saasCreator           SaasCreator?
  subscriptions         Subscription[]
  usageRecords          UsageRecord[]
  apiKeys               ApiKey[]
  emailNotifications    EmailNotification[]
  usageLimitEvents      UsageLimitEvent[]
  notifications         Notification[]
}

enum SubscriptionStatus {
  FREE
  PAID
  TRIAL
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

// SaaS Creator model - represents a SaaS business using the platform
model SaasCreator {
  id                  String              @id @default(cuid())
  userId              String              @unique
  user                User                @relation(fields: [userId], references: [id], onDelete: Cascade)
  businessName        String
  businessDescription String?             @db.Text
  website             String?
  onboardingCompleted Boolean             @default(false)
  onboardingStep      Int                 @default(1)
  // Brand data from crawler
  logoUrl             String?
  faviconUrl          String?
  primaryColor        String?
  secondaryColor      String?
  primaryLogo         String?
  fonts               String?             @db.Text // JSON array of fonts
  companyAddress      String?
  contactInfo         String?             @db.Text // JSON object with contact details
  productsParsed      String?             @db.Text // JSON array of products
  voiceAndTone        String?             @db.Text
  crawlJobId          String?
  crawlStatus         String?             @default("pending") // pending, processing, completed, failed
  crawlConfidence     String?             @db.Text // JSON object with confidence scores
  crawlCompletedAt    DateTime?
  lightweightScrape   Json?
  deepDesignTokens    Json?
  mergedScrapeData    Json?
  scrapedSite         ScrapedSite?        @relation("SaasCreatorToScrapedSite")
  designVersions      DesignVersion[]    @relation("SaasCreatorDesignVersions")
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt
  stripeAccount       StripeAccount?
  products            Product[]
  subscribers         Subscription[]
  whiteLabelConfig    WhiteLabelConfig?
  analyticsSnapshots  AnalyticsSnapshot[]
  apiKeys             ApiKey[]
}

// Stripe OAuth connection for SaaS creators
model StripeAccount {
  id              String      @id @default(cuid())
  saasCreatorId   String      @unique
  saasCreator     SaasCreator @relation(fields: [saasCreatorId], references: [id], onDelete: Cascade)
  stripeAccountId String
  accessToken     String?     @db.Text
  refreshToken    String?     @db.Text
  tokenType       String?
  scope           String?
  livemode        Boolean     @default(false)
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  @@index([stripeAccountId])
}

// Products offered by SaaS creators
model Product {
  id              String          @id @default(cuid())
  saasCreatorId   String
  saasCreator     SaasCreator     @relation(fields: [saasCreatorId], references: [id], onDelete: Cascade)
  name            String
  description     String?         @db.Text
  imageUrl        String?
  isActive        Boolean         @default(true)
  stripePriceId   String?
  stripeProductId String?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt
  tiers           Tier[]
  subscriptions   Subscription[]
  meteringConfig  MeteringConfig?
}

// Pricing tiers for products
model Tier {
  id                   String         @id @default(cuid())
  productId            String
  product              Product        @relation(fields: [productId], references: [id], onDelete: Cascade)
  name                 String
  description          String?        @db.Text
  priceAmount          Int // Amount in cents
  billingPeriod        String // monthly, yearly, etc.
  features             String[] // Array of feature descriptions
  usageLimit           Int? // Optional usage limit
  stripePriceId        String?        @unique
  prices               Json?
  isActive             Boolean        @default(true)
  sortOrder            Int            @default(0)
  createdAt            DateTime       @default(now())
  updatedAt            DateTime       @updatedAt
  subscriptions        Subscription[]
  // Limit enforcement fields
  softLimitPercent     Float?         @default(0.8) // Warning at 80%
  limitAction          String         @default("warn") // "block", "warn", "overage"
  overageAllowed       Boolean        @default(false)
  overageRate          Int? // Cost per unit over limit (cents)
  warningThresholds    Json? // Custom thresholds [0.7, 0.85, 0.95]
  // Stripe metered billing fields
  meteringEnabled      Boolean        @default(false)
  stripePriceIdMetered String?        @unique // Separate price for metered component
  unitPrice            Int? // Price per unit in cents (for metered)
}

// Subscriptions - linking subscribers to products and tiers
model Subscription {
  id                   String                   @id @default(cuid())
  userId               String?
  user                 User?                    @relation(fields: [userId], references: [id], onDelete: SetNull)
  saasCreatorId        String
  saasCreator          SaasCreator              @relation(fields: [saasCreatorId], references: [id], onDelete: Cascade)
  productId            String
  product              Product                  @relation(fields: [productId], references: [id], onDelete: Cascade)
  tierId               String
  tier                 Tier                     @relation(fields: [tierId], references: [id], onDelete: Cascade)
  stripeSubscriptionId String?                  @unique
  status               String                   @default("active") // active, canceled, past_due, etc.
  currentPeriodStart   DateTime?
  currentPeriodEnd     DateTime?
  cancelAtPeriodEnd    Boolean                  @default(false)
  createdAt            DateTime                 @default(now())
  updatedAt            DateTime                 @updatedAt
  usageRecords         UsageRecord[]
  usageLimitEvents     UsageLimitEvent[]
  stripeItems          StripeSubscriptionItem[]
}

// Metering configuration for products
model MeteringConfig {
  id                String   @id @default(cuid())
  productId         String   @unique
  product           Product  @relation(fields: [productId], references: [id], onDelete: Cascade)
  meteringType      String // requests, users, storage, compute, etc.
  meteringUnit      String // count, GB, hours, etc.
  aggregationType   String // sum, max, last_during_period
  usageReportingUrl String? // Webhook URL for usage reporting
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

// Usage tracking records
model UsageRecord {
  id             String       @id @default(cuid())
  subscriptionId String
  subscription   Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  userId         String
  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  quantity       Float
  timestamp      DateTime     @default(now())
  metadata       Json? // Additional context about the usage
  reportedAt     DateTime     @default(now())

  @@index([subscriptionId, timestamp])
  @@index([userId, timestamp])
}

// White-label site configuration for subscribers
model WhiteLabelConfig {
  id              String      @id @default(cuid())
  saasCreatorId   String      @unique
  saasCreator     SaasCreator @relation(fields: [saasCreatorId], references: [id], onDelete: Cascade)
  brandName       String?
  primaryColor    String?
  secondaryColor  String?
  logoUrl         String?
  faviconUrl      String?
  customDomain    String?     @unique
  subdomain       String?     @unique
  customCss       String?     @db.Text
  successRedirect String?
  isActive        Boolean     @default(true)
  pageVisibility  String      @default("public") // "public", "private", "unlisted"
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
}

// API Keys for authentication
model ApiKey {
  id            String       @id @default(cuid())
  userId        String?
  user          User?        @relation(fields: [userId], references: [id], onDelete: Cascade)
  saasCreatorId String?
  saasCreator   SaasCreator? @relation(fields: [saasCreatorId], references: [id], onDelete: Cascade)
  name          String
  key           String       @unique
  keyPrefix     String? // First 8 chars for display
  permissions   String[] // Array of permissions
  lastUsedAt    DateTime?
  expiresAt     DateTime?
  isActive      Boolean      @default(true)
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  @@index([userId])
  @@index([saasCreatorId])
  @@index([key])
}

// Email notification tracking
model EmailNotification {
  id        String    @id @default(cuid())
  userId    String
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String // subscription_created, payment_failed, etc.
  subject   String
  body      String    @db.Text
  recipient String
  status    String    @default("pending") // pending, sent, failed
  sentAt    DateTime?
  error     String?   @db.Text
  metadata  Json?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([userId])
  @@index([status])
  @@index([createdAt])
}

// Webhook events from Stripe
model WebhookEvent {
  id          String    @id @default(cuid())
  eventId     String    @unique // Stripe event ID
  eventType   String
  status      String    @default("pending") // pending, processed, failed
  payload     Json
  processedAt DateTime?
  error       String?   @db.Text
  retryCount  Int       @default(0)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([eventType])
  @@index([status])
  @@index([createdAt])
}

// Analytics snapshots for performance
model AnalyticsSnapshot {
  id                 String       @id @default(cuid())
  saasCreatorId      String?
  saasCreator        SaasCreator? @relation(fields: [saasCreatorId], references: [id], onDelete: Cascade)
  period             String // daily, weekly, monthly
  periodStart        DateTime
  periodEnd          DateTime
  totalRevenue       Int          @default(0)
  newSubscribers     Int          @default(0)
  churnedSubscribers Int          @default(0)
  activeSubscribers  Int          @default(0)
  totalUsage         Float        @default(0)
  metadata           Json?
  createdAt          DateTime     @default(now())
  updatedAt          DateTime     @updatedAt

  @@unique([saasCreatorId, period, periodStart])
  @@index([saasCreatorId])
  @@index([periodStart])
}

model ScrapedSite {
  id              String           @id @default(cuid())
  saasCreatorId   String           @unique
  saasCreator     SaasCreator      @relation("SaasCreatorToScrapedSite", fields: [saasCreatorId], references: [id], onDelete: Cascade)
  url             String           @unique
  domain          String?
  title           String?
  description     String?
  crawledAt       DateTime         @default(now())
  rawHtml         String?
  screenshot      Bytes?
  logoUrls        Json?
  primaryLogo     String?
  companyInfo     CompanyInfo?     @relation("ScrapedSiteToCompanyInfo")
  designTokens    DesignToken[]    @relation("ScrapedSiteToDesignToken")
  scrapedProducts ScrapedProduct[] @relation("ScrapedSiteToScrapedProduct")
  brandVoice      BrandVoice?      @relation("ScrapedSiteToBrandVoice")

  @@index([url])
  @@index([domain])
}

model CompanyInfo {
  id             String      @id @default(cuid())
  scrapedSiteId  String      @unique
  scrapedSite    ScrapedSite @relation("ScrapedSiteToCompanyInfo", fields: [scrapedSiteId], references: [id], onDelete: Cascade)
  companyName    String?
  legalName      String?
  contactEmails  String[]
  contactPhones  String[]
  addresses      String[]
  structuredJson Json?
  createdAt      DateTime    @default(now())

  @@index([scrapedSiteId])
}

model DesignToken {
  id            String      @id @default(cuid())
  scrapedSiteId String
  scrapedSite   ScrapedSite @relation("ScrapedSiteToDesignToken", fields: [scrapedSiteId], references: [id], onDelete: Cascade)
  tokenKey      String
  tokenType     String
  tokenValue    String
  source        String?
  meta          Json?
  createdAt     DateTime    @default(now())

  @@index([scrapedSiteId])
  @@index([tokenType])
}

model ScrapedProduct {
  id            String      @id @default(cuid())
  scrapedSiteId String
  scrapedSite   ScrapedSite @relation("ScrapedSiteToScrapedProduct", fields: [scrapedSiteId], references: [id], onDelete: Cascade)
  name          String
  slug          String?
  price         String?
  description   String?
  productUrl    String?
  metadata      Json?
  createdAt     DateTime    @default(now())

  @@index([scrapedSiteId])
}

model BrandVoice {
  id            String                       @id @default(cuid())
  scrapedSiteId String                       @unique
  scrapedSite   ScrapedSite                  @relation("ScrapedSiteToBrandVoice", fields: [scrapedSiteId], references: [id], onDelete: Cascade)
  summary       String?
  guidelines    Json?
  embedding     Unsupported("vector(1536)")?
  createdAt     DateTime                     @default(now())

  @@index([scrapedSiteId])
}

// Usage limit event tracking
model UsageLimitEvent {
  id               String       @id @default(cuid())
  subscriptionId   String
  subscription     Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  userId           String
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  eventType        String // "warning", "critical", "exceeded", "reset"
  threshold        Float // 0.8, 0.9, 1.0
  currentUsage     Float
  usageLimit       Int
  percentage       Float
  timestamp        DateTime     @default(now())
  notificationSent Boolean      @default(false)
  notifiedAt       DateTime?
  metadata         Json?

  @@index([subscriptionId, timestamp])
  @@index([userId, timestamp])
  @@index([eventType])
}

// Stripe subscription item tracking for metered billing
model StripeSubscriptionItem {
  id                       String       @id @default(cuid())
  subscriptionId           String
  subscription             Subscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)
  stripeSubscriptionItemId String       @unique
  stripePriceId            String
  itemType                 String // "base_fee" or "metered_usage"
  meteringType             String? // "api_calls", "storage", etc.
  lastReportedUsage        Float?       @default(0)
  lastReportedAt           DateTime?
  createdAt                DateTime     @default(now())
  updatedAt                DateTime     @updatedAt

  @@index([subscriptionId])
  @@index([stripeSubscriptionItemId])
}

model Notification {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  type      String   // e.g., "new_subscriber", "payment_failed"
  title     String?
  message   String   @db.Text
  isRead    Boolean  @default(false)
  metadata  Json?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([userId, isRead])
  @@index([createdAt])
}

model DesignVersion {
  id            String      @id @default(cuid())
  saasCreatorId String
  saasCreator   SaasCreator @relation("SaasCreatorDesignVersions", fields: [saasCreatorId], references: [id], onDelete: Cascade)
  version       Int         @default(1)
  tokensJson    Json
  whiteLabelJson Json
  isActive      Boolean     @default(true)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  @@index([saasCreatorId])
  @@index([isActive])
}

// prisma/schema.prisma
// Database schema for production embed system with URL shortening

// Short codes for ultra-compact embeds
model ShortCode {
  id          String   @id @default(cuid())
  code        String   @unique @db.VarChar(12)
  config      String   @db.Text // Base64 encoded config
  widgetId    String   @db.VarChar(100)
  widget      Widget?  @relation(fields: [widgetId], references: [id])
  
  // Metadata
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  expiresAt   DateTime?
  
  // Analytics
  clicks      Int      @default(0)
  lastUsedAt  DateTime?
  
  // Optional user association
  userId      String?  @db.VarChar(100)
  
  @@index([code])
  @@index([widgetId])
  @@index([userId])
  @@index([createdAt])
  @@map("short_codes")
}

// Widget configurations
model Widget {
  id              String      @id @default(cuid())
  widgetId        String      @unique @db.VarChar(100)
  name            String      @db.VarChar(255)
  contentType     WidgetType
  
  // Design tokens (stored as JSON)
  designTokens    Json
  
  // Configuration
  apiEndpoint     String      @default("/api/embed/content")
  customCSS       String?     @db.Text
  customJS        String?     @db.Text
  
  // Status
  isActive        Boolean     @default(true)
  isPublic        Boolean     @default(false)
  
  // Metadata
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  // Relations
  userId          String?     @db.VarChar(100)
  shortCodes      ShortCode[]
  analytics       WidgetAnalytics[]
  submissions     FormSubmission[]
  chatMessages    ChatMessage[]
  
  @@index([widgetId])
  @@index([userId])
  @@index([contentType])
  @@index([isActive])
  @@map("widgets")
}

// Widget types enum
enum WidgetType {
  CHAT
  FORM
  NOTIFICATION
  CUSTOM
}

// Analytics tracking
model WidgetAnalytics {
  id              String   @id @default(cuid())
  widgetId        String
  widget          Widget   @relation(fields: [widgetId], references: [id], onDelete: Cascade)
  
  // Event data
  eventType       AnalyticsEvent
  eventData       Json?
  
  // User info (anonymized)
  sessionId       String?  @db.VarChar(100)
  userAgent       String?  @db.VarChar(500)
  ipHash          String?  @db.VarChar(64) // Hashed IP for privacy
  referrer        String?  @db.VarChar(500)
  
  // Location (optional)
  country         String?  @db.VarChar(2)
  city            String?  @db.VarChar(100)
  
  // Timestamp
  createdAt       DateTime @default(now())
  
  @@index([widgetId])
  @@index([eventType])
  @@index([createdAt])
  @@index([sessionId])
  @@map("widget_analytics")
}

enum AnalyticsEvent {
  LOAD
  VIEW
  CLICK
  SUBMIT
  CLOSE
  MINIMIZE
  ERROR
}

// Form submissions
model FormSubmission {
  id              String   @id @default(cuid())
  widgetId        String
  widget          Widget   @relation(fields: [widgetId], references: [id], onDelete: Cascade)
  
  // Form data (stored as JSON for flexibility)
  formData        Json
  
  // Contact info
  name            String?  @db.VarChar(255)
  email           String?  @db.VarChar(255)
  phone           String?  @db.VarChar(50)
  
  // Status
  status          SubmissionStatus @default(NEW)
  assignedTo      String?  @db.VarChar(100)
  notes           String?  @db.Text
  
  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  // Source tracking
  referrer        String?  @db.VarChar(500)
  userAgent       String?  @db.VarChar(500)
  
  @@index([widgetId])
  @@index([status])
  @@index([createdAt])
  @@index([email])
  @@map("form_submissions")
}

enum SubmissionStatus {
  NEW
  IN_PROGRESS
  COMPLETED
  SPAM
  ARCHIVED
}

// Chat messages
model ChatMessage {
  id              String   @id @default(cuid())
  widgetId        String
  widget          Widget   @relation(fields: [widgetId], references: [id], onDelete: Cascade)
  
  // Message content
  message         String   @db.Text
  sender          MessageSender
  
  // Session tracking
  sessionId       String   @db.VarChar(100)
  
  // AI/Agent info
  agentId         String?  @db.VarChar(100)
  aiModel         String?  @db.VarChar(50)
  
  // Metadata
  createdAt       DateTime @default(now())
  
  // Optional: parent message for threading
  parentId        String?
  
  @@index([widgetId])
  @@index([sessionId])
  @@index([createdAt])
  @@map("chat_messages")
}

enum MessageSender {
  USER
  BOT
  AGENT
}

// User/account model (optional - if you have authentication)
model EmbedUser {
  id              String   @id @default(cuid())
  email           String   @unique @db.VarChar(255)
  name            String?  @db.VarChar(255)
  
  // Plan/limits
  plan            UserPlan @default(FREE)
  widgetLimit     Int      @default(3)
  
  // API access
  apiKey          String?  @unique @db.VarChar(64)
  
  // Metadata
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  lastLoginAt     DateTime?
  
  @@index([email])
  @@index([apiKey])
  @@map("users")
}

enum UserPlan {
  FREE
  STARTER
  PRO
  ENTERPRISE
}

// Rate limiting (optional)
model RateLimit {
  id              String   @id @default(cuid())
  identifier      String   @unique @db.VarChar(255) // IP, API key, or user ID
  
  // Limits
  requestCount    Int      @default(0)
  windowStart     DateTime @default(now())
  
  // Metadata
  updatedAt       DateTime @updatedAt
  
  @@index([identifier])
  @@index([windowStart])
  @@map("rate_limits")
}